package pipeline

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"df2redis/internal/config"
)

// GenerateShakeConfigFile creates a redis-shake TOML config under the state directory
// when shakeArgs/config are missing. The config references the configured snapshot
// and target connection details.
func GenerateShakeConfigFile(cfg *config.Config, stateDir string) (string, error) {
	snapshot := strings.TrimSpace(cfg.Migrate.SnapshotPath)
	if snapshot == "" {
		return "", fmt.Errorf("snapshotPath not set; cannot generate shake config")
	}
	if stateDir == "" {
		return "", fmt.Errorf("stateDir not configured; cannot generate shake config")
	}
	if err := os.MkdirAll(stateDir, 0o755); err != nil {
		return "", fmt.Errorf("failed to create state directory: %w", err)
	}
	path := filepath.Join(stateDir, "shake.generated.toml")
	// Calculate relative path from stateDir (shake's work dir) to logDir
	// redis-shake v4 joins 'dir' + 'log_file', so we must provide a relative path if we want it elsewhere.

	// Use cfg.ResolvePath which handles resolution relative to config file location correctly
	absLogDir := cfg.ResolvePath(cfg.Log.Dir)
	if absLogDir == "" {
		absLogDir = cfg.ResolvePath("logs") // Fallback
	}

	shakeLogName := "shake.log"
	if cfg.TaskName != "" {
		shakeLogName = fmt.Sprintf("%s_shake.log", cfg.TaskName)
	}
	// Calculate relative path from stateDir (shake's work dir) to logDir
	// redis-shake v4 joins 'dir' + 'log_file', so we must provide a relative path if we want it elsewhere.
	absStateDir, _ := filepath.Abs(stateDir)
	relLogPath, err := filepath.Rel(absStateDir, filepath.Join(absLogDir, shakeLogName))
	if err != nil {
		// Fallback to simple filename if rel path fails, it will go to stateDir
		relLogPath = shakeLogName
	}
	logPath := relLogPath
	targetCluster := strings.Contains(strings.ToLower(cfg.Target.Type), "cluster")

	// Map QPS: 0 in df2redis means unlimited.
	// However, redis-shake panics if target_redis_max_qps is 0 (divide by zero in ratelimit).
	// We set it to a sufficiently large value (e.g. 1000000) to effectively simulate "unlimited".
	qps := cfg.Advanced.QPS
	if qps <= 0 {
		qps = 1_000_000
	}

	pipelineCount := cfg.Advanced.BatchSize
	if pipelineCount <= 0 {
		pipelineCount = 1024
	}

	content := fmt.Sprintf(`# auto-generated by df2redis
[rdb_reader]
filepath = "%s"

[redis_writer]
cluster = %t
address = "%s"
username = ""
password = "%s"
tls = %t
off_reply = false

[filter]
allow_keys = []
allow_key_prefix = []
allow_key_suffix = []
allow_key_regex = []
block_keys = []
block_key_prefix = []
block_key_suffix = []
block_key_regex = []
allow_db = []
block_db = []
allow_command = []
block_command = []
allow_command_group = []
block_command_group = []
function = ""

[advanced]
dir = "%s"
ncpu = 0
pprof_port = 0
status_port = 0
log_file = "%s"
log_level = "info"
log_interval = 5
log_rotation = true
log_max_size = 512
log_max_age = 7
log_max_backups = 3
log_compress = true
pipeline_count_limit = %d
target_redis_max_qps = %d
target_redis_client_max_querybuf_len = 1073741824
target_redis_proto_max_bulk_len = 512000000
empty_db_before_sync = false
`, snapshot, targetCluster, cfg.Target.Addr, cfg.Target.Password, cfg.Target.TLS, stateDir, logPath, pipelineCount, qps)

	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return "", fmt.Errorf("failed to write shake config: %w", err)
	}
	cfg.Migrate.ShakeConfigFile = path
	return path, nil
}
