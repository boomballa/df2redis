# df2redis 后台运行指南

## 问题背景

在通过跳板机 SSH 登录服务器执行长时间任务时，常见问题：
- SSH 会话超时（如 30 分钟）
- 会话断开后进程被终止
- 需要使用 `nohup` 或 `screen` 等工具

## df2redis 的解决方案

**df2redis v2.x 内置了后台运行能力**，无需依赖外部工具。

### 核心机制

1. **忽略 SIGHUP 信号**
   - 当 SSH 会话断开时，shell 会向所有子进程发送 SIGHUP
   - df2redis 自动忽略 SIGHUP，避免被终止

2. **双重日志输出**
   - 同时写入控制台和文件
   - 当 stdout 不可用时，文件日志继续工作
   - 自动检测 TTY，无终端时禁用控制台输出

3. **健壮的 I/O 处理**
   - 写入失败不会导致程序崩溃
   - 文件日志保证持久化

## 使用方法

### 方式 1：后台执行（推荐）

```bash
# 标准用法：指定配置文件和任务名，使用 & 后台执行
./bin/df2redis replicate --config examples/replicate.sample.yaml --task-name my-task &

# 查看日志（根据 task-name 生成的日志文件）
tail -f log/my-task_replicate.log
```

**重要**：
- ✅ 必须指定 `--config` 配置文件路径
- ✅ 建议指定 `--task-name` 便于区分不同任务的日志
- ✅ 使用 `&` 放到后台执行
- ✅ 日志自动写入文件（`log/{task-name}_{mode}.log`）
- ✅ SSH 断开后进程继续运行（不会在 1800s 后被杀）

**实际示例**：
```bash
# 增量复制任务
./bin/df2redis replicate --config config/prod.yaml --task-name dragonfly-to-redis &

# 一致性检查任务
./bin/df2redis check --config config/prod.yaml --task-name consistency-check &

# 冷导入任务
./bin/df2redis cold-import --config config/import.yaml --task-name initial-import &
```

**查看进程**：
```bash
ps aux | grep df2redis
```

**查看日志**：
```bash
# 实时查看
tail -f log/{task-name}_replicate.log

# 查看最近 100 行
tail -n 100 log/{task-name}_replicate.log
```

### 方式 2：重定向输出（可选）

```bash
# 如果不想看到控制台输出，可以重定向到 /dev/null
./bin/df2redis replicate --config config.yaml --task-name my-task >/dev/null 2>&1 &

# 或者保留控制台输出到单独文件（一般不需要，因为已有日志文件）
./bin/df2redis replicate --config config.yaml --task-name my-task >console.log 2>&1 &
```

**说明**：
- ⚠️ 工具已经有完善的文件日志系统（`log/{task-name}_replicate.log`）
- 重定向只是避免控制台输出，不影响日志文件
- 一般情况下不需要重定向，直接 `&` 即可

### 方式 3：使用 nohup（额外保险）

```bash
# 如果担心兼容性，可以额外加上 nohup（实际上已经不需要了）
nohup ./bin/df2redis replicate --config config.yaml --task-name my-task &

# 查看日志
tail -f log/my-task_replicate.log
```

**说明**：
- v2.x 版本已经内置了防 SIGHUP 机制，nohup 是可选的
- 如果在老旧系统上不放心，可以加上 nohup 作为双重保险
- 不影响功能，只是多了一层保护

### 方式 4：使用 screen 或 tmux（调试时使用）

```bash
# 创建 screen 会话
screen -S df2redis-task1

# 在会话中运行（注意：仍然需要指定配置文件）
./bin/df2redis replicate --config examples/replicate.sample.yaml --task-name task1

# 分离会话: Ctrl+A 然后 D

# 重新连接查看实时输出
screen -r df2redis-task1

# 列出所有会话
screen -ls
```

**适用场景**：
- 需要实时查看控制台输出
- 调试和排查问题
- 需要交互式操作（如手动 Ctrl+C 停止）
- 可以运行多个独立任务（每个 screen 会话一个）

## 生产环境使用

### 标准用法

```bash
# 1. 准备配置文件
vi config/prod-task1.yaml

# 2. 后台启动
./bin/df2redis replicate --config config/prod-task1.yaml --task-name prod-task1 &

# 3. 记录 PID
echo $! > run/prod-task1.pid

# 4. 查看日志
tail -f log/prod-task1_replicate.log
```

### 运行多个任务

```bash
# 任务 1：Dragonfly A → Redis Cluster A
./bin/df2redis replicate --config config/task1.yaml --task-name task1 &

# 任务 2：Dragonfly B → Redis Cluster B
./bin/df2redis replicate --config config/task2.yaml --task-name task2 &

# 任务 3：一致性检查
./bin/df2redis check --config config/task1.yaml --task-name check1 &

# 查看所有任务
ps aux | grep df2redis

# 查看日志
ls -lh log/
tail -f log/task1_replicate.log
tail -f log/task2_replicate.log
tail -f log/check1_check.log
```

## 技术细节

### SIGHUP 处理

```go
// internal/cli/cli.go
signal.Ignore(syscall.SIGHUP)
```

- 在 Execute() 入口处执行
- 对所有子命令生效
- 符合 Unix 信号处理最佳实践

### TTY 自动检测

```go
// 检测 stdout 是否是终端
if fileInfo, _ := os.Stdout.Stat(); (fileInfo.Mode() & os.ModeCharDevice) == 0 {
    // 不是 TTY，自动禁用控制台输出
    consoleEnabled = false
}
```

**效果**：
- 有终端时：显示彩色输出和进度
- 无终端时：自动禁用控制台，提高性能

### 健壮的输出处理

```go
// 写入失败不会崩溃
_, _ = fmt.Fprintf(os.Stdout, message)
```

- 即使 stdout 关闭，程序继续运行
- 文件日志保证可靠性

## 常见问题

### Q1: 为什么不用 nohup？

**A**: df2redis 内置了相同的能力，使用更简单。但如果你习惯 nohup，仍然可以使用。

### Q2: 日志在哪里？

**A**:
- 默认位置：`log/{prefix}_{mode}.log`
- prefix 根据配置中的 taskName 或源库信息生成
- 示例：`log/dragonfly_192.168.1.100_6379_replicate.log`

### Q3: 如何知道进程还在运行？

```bash
# 查看进程
ps aux | grep df2redis

# 查看日志（实时）
tail -f log/xxx_replicate.log

# 查看状态文件
cat state/status.json
```

### Q4: 如何优雅停止？

```bash
# 找到进程 PID
ps aux | grep df2redis

# 发送 SIGTERM（优雅退出）
kill -TERM <PID>

# 或使用 SIGINT (Ctrl+C)
kill -INT <PID>
```

df2redis 会：
- 捕获信号
- 完成当前操作
- 保存检查点
- 关闭连接
- 刷新日志

### Q5: 重启后如何恢复？

```bash
# 直接重新运行相同命令
./df2redis replicate --config config.yaml &

# df2redis 会自动：
# 1. 读取状态文件
# 2. 从断点恢复（如果启用了 checkpoint）
# 3. 继续复制
```

## 版本对比

### df2redis v1.x vs v2.x

| 特性 | v1.x | v2.x |
|------|------|------|
| SIGHUP 处理 | ❌ 会被终止 | ✅ 自动忽略 |
| 后台运行 | 必须 nohup | ✅ 直接 & |
| 双重日志 | ✅ Console + File | ✅ Console + File |
| TTY 检测 | ❌ | ✅ 自动检测 |
| 配置文件 | 必须指定 | 必须指定 |
| 命令行参数 | 完整参数 | 完整参数（兼容） |

### redis-shake vs df2redis v2.x

| 特性 | redis-shake | df2redis v2.x |
|------|------------|--------------|
| SIGHUP 处理 | ❌ 无处理 | ✅ 明确忽略 |
| 双重日志 | ✅ Console + File | ✅ Console + File |
| TTY 检测 | ❌ | ✅ 自动检测 |
| 后台运行 | 依赖运气/nohup | ✅ 内置支持 |

## 总结

### 核心改进

**v2.x 版本的改进**：内置 SIGHUP 防护，不再需要 nohup

**改动前（v1.x）**：
```bash
# 必须使用 nohup，否则 1800s 后被杀
nohup ./bin/df2redis replicate --config config.yaml --task-name my-task &
```

**改动后（v2.x）**：
```bash
# 直接使用 &，SSH 断开后继续运行
./bin/df2redis replicate --config config.yaml --task-name my-task &
```

### 标准使用方式

**日常使用**：
```bash
./bin/df2redis replicate --config examples/replicate.sample.yaml --task-name fix-ack-version &
```

**调试场景**：
```bash
screen -S my-task
./bin/df2redis replicate --config config.yaml --task-name my-task
# Ctrl+A D 分离，screen -r my-task 重连
```

**多任务场景**：
```bash
./bin/df2redis replicate --config config/task1.yaml --task-name task1 &
./bin/df2redis replicate --config config/task2.yaml --task-name task2 &
./bin/df2redis check --config config/task1.yaml --task-name check1 &
```

### 关键要点

- ✅ **必须指定配置文件**：`--config` 参数不可省略
- ✅ **建议指定任务名**：`--task-name` 便于区分日志
- ✅ **使用 & 后台执行**：SSH 断开不影响运行
- ✅ **查看日志文件**：`tail -f log/{task-name}_{mode}.log`
- ✅ **严谨的工具**：所有参数和配置保持原样，只是更稳定
